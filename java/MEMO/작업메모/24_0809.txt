복습 
<추상화>

-추상클래스를 직접 객체화 할 수는없다.
-만약 추상 메서드를 하나라도 가지고 있다면 추상클래스로 정의해야한다.
-추상클래스를 상속받는 클래스들이 추상메서드를 상속받아 무조건 오버라이드(재정의) 해야한다.

<인터페이스>

-인터페이스 에는 상수와 추상메서드만 들어갈 수 있다.
- 상수 -> 값을 초기화 하면, 다시 대입이 불가능
상수이름은 대문자로 작성을 한다.
- 추상메서드 ->  abstract 키워드를 생략해도 된다.
- 인터페이스도 객체 생성이 안된다.
------------------------------------------------------------------------------


<다중 인터페이서의 구현 (implements)>

- 하나의 클래스로 여러개의 인터페이스를 구현할 수 있다.
- 선언한 모든 인터페이스에 대한 추상 메서드를 모두 구현 해줘야한다.
	class 클래스명 implements 인터페이스1, 인터페이스2{
		필드, 
		메서드,
		생성자,
		추상메서드의 구현체
	}

<인터페이스 상속>

- 인터페이스끼리 상속 관계를 만들 수 있다.
- 클래스에서의 상속과 마찬가지로 esxtends 키워드를 사용하며,
  다중 상속이 가능하기 때문에 콤마를 이용해서 여러개를 상속하는것이 가능

	interface 인터페이스명 extends 인터페이스1,인터페이스2,...{
		
	}

- 인터페이스 상속을 선언하면, 하위 인터페이스는 상위 인터페이스의 
  모든 멤버를 상속받게 된다.
- 하위 인터페이스를 구현하는 클래스가 있다면, 해당 클래스는 하위 인터페이스의 추상 메서드를   포함하여 상위 인터페이스들의 추상메서드까지 구현해야한다.

<내부 클래스>

- 클래스 안에 만들어진 또 다른 클래스로 중첩 클래스 라고도 부른다.
- 클래스 안에 다른 클래스를 선언하는 이유는 두개의 클래스가 서로 긴밀한 관계를 맺고 있기 때문이다.

<내부 클래스의 장점>

- 두 클래스 멤버들 간에 손쉽게 접근할 수 있다.
- 불필요한 클래스를 감취 코드의 복잡성을 줄일 수 있다.

	public class OuterClass{ //외부 클래스
		class InnerClass{ //내부 클래스
		}
	}
<내부 클래스의 종류>

1.인스턴스 클래스
- 외부 클래스의 필드와 같은 위치에 선언
- 주로 외부 클래스의 클래스 멤버 변수와 관련된 작업에 사용될 목적으로 선언

2. 정적 클래스
- 클래스의 클래스 변수처럼(정적변수)
- 내부 클래스의 static을 붙힌 클래스

3. 지역 클래스
- 외부 클래스의 메서드 내부에서 선언하여 사용
- 메서드 영역에서 선언되기 때문에 메서드 내부에서만 사용이 가능

<인스턴스 클래스>
- 외부 클래스 내부에서 생성하고, 선언되어 사용하는 클래스
- 외부 클래스의 필드와 같은 위치에 선언하며 내부 클래스의 필드처럼 다뤄진다.
- 주로 외부클래스의 필드들과 관련된 작업에 사용될 목적으로 선언된다.
public class Outer{
	private String name;//필드
	
	//인스턴스 클래스가 들어갈 수 있다.
	public class inner{
		private int age;
	}
}
- 내부 클래스도 외부 클래스안에 생성되는것 외에는 별도의 클래스이기때문에, 파일이 컴파일 되면   별도로 생성된다.

<인스턴스 클래스의 객체화>
- 인스턴스 클래스는 기본적인 내부클래스이다.
- 외부 클래스 안에 생성되기 때문에, 클래스를 사용하려면 외부 클래스의 객체가 생성된 상태에서
  객체를 생성할 수 있다.

	Outer outer = new Outer(); //외부클래스의 객체 생성
	Outer.inner innner = outer.new Inner(); //외부 클래스를 이용해 내부 클래스 객체 생성

<정적 내부 클래스 (static class)>
- 클래스 안에 정적 변수를 선언할 수 있는 것 처럼
  클래스도 정적 내부 클래스를 만들 수 있다.
- 필드와 마찬가지로 static키워드를 사용해 클래스를 선언한 후 
  정적 내부 클래스를 생성한다.
- 주로 외부 클래스의 static메서드에서 사용될 목적으로 만든다.

public class Outer{
    private String name;
    public  static class Inner{
	private String name;	
    }
}
- 외부 클래스의 필드 또는 메서드를 정적 내부 클래스 안에서는 사용할 수 없다.

public class Outer{
	private int val1; //필드

	public static class Inner{
		public void add(){
			int result = val1 + 10; -> 에러
		} //val1을 사용하려고 하면 에러남
	}
}
- 정적 내부 클래스는 정적 변수 또는 정적 메서드를 호출하는것은 가능하다.

public class Outer{
	private int val1; //일반적인 필드
	private static int cnt = 1; //클래스 정적 변수

	public static class Inner{
		public void displayOuterInfo(){
			System.out.println(val); ->일반적인 필드기 때문에 에러가 남
			System.out.println(cnt);-> 이런식으로 정적 메서드 , 변수만 사용가능
		}
	}
}

<정적 내부 클래스의 객체 생성>
Outer.Inner in = new Outer.Inner();

<지역 클래스(local class>
- 외부 클래스의 메서드안에서 선언하여 사용하는 클래스
- 메서드내에서 선언되기 때문에 해당 클래스는 메서드 내에서만 사용할 수 있다.
- 메서드의 실행이 끝나면 해당 클래스도 사용이 종료된다.

public class LocalClass{
	public void print(){
		//////////////////////////
		class A{
			지역 클래스 선언
		}
		A a = new A(); 메서드 내에서 사용
		///////////////////////
	}
}

<내부 클래스의 접근 제한>
- 내부 클래스도 클래스이기 때문에 접근 제한자를 붙여서 사용할 수 있다.
------------------------------------------------------------------------------------

예외처리
에러(error)와 예외(exception)
- 프로그램을 실행하다 보면 갑자기 프로그램이 종료되거나 어떤 원인에 의해 잘못 동작하여 
  오류 메시지가 나타나는 등 예기치 못한 오류가 발생한다.
- 전자는 우리가 해결할 수 없는 시스템 에러가 발생해 프로그램이 종료된 경우이며
  후자는 프로그램 사용중 발생한 오류를 개발자가 처리해 메시지가 출력된 경우이다.

에러(error)
- 시스템이 비정상적인 상황이 생겼을 때 발생한다.
- 외부요인일수도 있고, 프로그램 구동중에 발생하는 치명적인 오류일 수 도 있다.
- 이러한 에러들은 개발자가 예측하거나 처리할 수 없는 영역이다.

OutOfMemoryError 프로그램 실행중 메모리 부족
IOError 입출력 에러
StackOverFlowError 가용 메모리 부족 현상, 재귀 호출 문제시 발생

예외(exception)
- 대체로 프로그램 구동 중에 나타나는 오류들
- 문법적으로는 문제가 없어 보이지만 실제 운영 중에 생기는 문제들
- 체크예외 비체크 예외 두가지가 있다.

체크예외
- 자바 소스를 컴파일 하는 과정에서 검사 한다.
- 보통 문법적으로 강제하여 예외 처리를 해야 하는 경우

비체크 예외
- 컴파일 과정에서 검사하지 않으므로 사용자의 경험이나 테스트로 찾아야 하는 경우

예외 클래스
- 자바는 객체 지향언어이고 따라서 프로그램에서 발생하는 예외들은 클래스 형태로 제공된다.

NullPointerException
- 객체가 제대로 생성되지 않은 상태에서 사용할 경우 발생한다.
- 객체를 선언하면, 주소를 갖게 되고, 그것을 통해 객체에 접근해 값을 가져온다.
- 객체변수는 정의되었는데 메모리에 올리지 않았을때 예외가 발생한다.

예외처리문법
- 예외가 발생했을 때, 어떻게 예외 처리를 하는지 방법에 대해서 알아보자

예외처리 과정
1. 코드 진행 중 예외가 발생하면 JVM에게 알린다
2. JVM은 발생한 예외를 분석하여 알맞은 예외 클래스를 생성한다
3. 생성된 예외 객체를 발생한 지점으로 보낸다
4. 예외가 발생한 지점에서 처리하지 않으면 프로그램은 비정상 종료된다

try - catch 구문
- 예외를 처리하는 가장 기본 문법은 try - catch 문이다.
- 예외가 발생할 가능성이 있는 코드는 try{}안에 작성하고
- catch 메서드는 시스템으로 부터 넘어오는 예외 클래스를 받아서 처리한다.
	try {
    		예외가 발생할 가능성이 있는 코드 (에러가 생길만한 코드)
	} catch (예외 클래스명 e) {
    		예외처리 코드
	}

<예외 던지기(throws)>
- 메서드 내부에서 예외를 처리하지않고 미룬후, 해당메서드를 호출한 쪽에서
  예외를 처리하는 방법을 칭한다.
   throws
- 메서드 뒤에 throws 키워드를 사용하요 던지기 할 예외 객체를 붙여주면 된다.
- 예외 객체는 여러개를 던질 수 있으며, 여러 개를 던질 시 콤마로 구분하여 나열해준다.
