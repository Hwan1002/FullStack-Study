<복습>

*상속을 하는 이유

-부모클래스 -> 넓은 범위의 범주 (ex:차) 
중복되는것을 제외
변수: (ex:핸들,바퀴,엑셀,문)
메서드: 달리다, 멈추다

-자식클래스 -> 좁은 범위의 범주 (ex:버스,트럭,승용차)

*상속의 특징

1. 다중상속을 받는게 불가능하다.(다이아몬드 문제)
2. 최상위 클래스는 Object다.
3. 하나의 부모 클래스는 여러 자식 클래스를 갖는것은 가능하다.

*오버라이딩

1. 부모클래스의 메서드를 재정의하는것.
2. 반환형,메서드명,매개변수를 그대로 써야한다. (내용만 재정의 해야한다.)
3. 범위는 더 넓게 사용이 가능하다. (default -> public)

*super;

- 부모클래스를 지칭하는 키워드
- super.필드 -> 부모의 필드 호출 가능
- super.메서드 -> 부모의 메서드 호출
- super() -> 부모의 생성자 호출
- 자식클래스의 객체가 만들어질 때 부모 클래스의 멤버를 사용할 수 있는 이유는
자식 생성자 안에서 부모생성자(super())가 호출되기 때문이다.

*접근제한자
1. public : 제한없이 접근 가능
2. protected : 같은 패키지에서 접근가능, 다른패키지라도 자식클래스면 접근가능(super로만 접근가능)
3. default : 클래스 앞에 안쓰면 default, 같은패키지 내에서만 접근이 가능하다.
4. private: 같은 클래스 내에서만 접근이 가능하다.

동적바인딩 -> 프로그램이 실행될 때 객체의 실제 타입에 따라 어떤 메서드가 실행되는지 결정된다.

speedcoder


클래스 타입변환 -> 자동타입 변환
강제타입 변환 -> 부모타입으로 변환을 했지만 자식 클래스의 멤버에 접근 하고 싶을 때가 있을 수 있다.

자바의 규약으로 자식 클래스의 멤버에 접근할 수 없으므로 이러한 경우 다시 자식타입으로 변경해서 접근할 수 있도록 해야한다.

클래스의 강제 타입 변환이라고 부른다.
자식 객체가 부모타입으로 자동 타입변환을 한후, 다시 자식 타입으로 변환하는것을 말한다.

일회성으로 타입 변환이 필요할 때
((자식 클래스명)객체명).메서드명();

자식클래스의 멤버에 접근이 여러번 필요한 경우
변수명 = (자식 클래스)부모타입객체;

객체지형의 특징
***잘쓸줄 알아야함***

<다형성>
- 객체 지향 프로그래밍의 대표적인 특징 중 하나로,
하나의 타입으로 다양한 객체를 사용할 수 있는것
-자바에서는 클래스 타입 변환을 통해, 부모 클래스 타입 하나로
여러가지 자식 객체들을 참조하여 사용함으로써, 다형성을 구현할 수 있다.

-완벽한 다형성을 구현하기 위해 
상속 + 오버라이딩 + 클래스 타입 변환의 세가지 개념을 합쳐야 한다.

-객체가 특정 클래스의 필드가 되면서, 하나의 부품처럼 사용할 수 있다.
이때 부품을 교체할 일이 생긴다면 우리는 다형성을 구현함으로써 코드 수정을 최소화 할 수 있다.


instanceof 연산자
-부모타입으로 타입이 변환되어 저장된 변수는 안에 어떤 객체가 담겨 있는지
직접 확인하지 않는 이상 내부 객체를 알기 쉽지 않다.

-오버라이딩된 메서드가 있다면 확인이 쉽겠지만, 부모클래스를 같이 상속받고 있는
다른 클래스 또는 부모 클래스와 구별할 수 있는 특정 멤버가 없다면 어떻게 구별해야 할까?

-instanceof 연산자의 특징
-A instanceof B : A 객체가 생성될 때 B타입으로 생성되었는지 확인하는 연산자
- 맞으면 true, 아니면 false를 반환하며 만약 null을 가리키고 있으면 false를 반환한다.

객체명 instance of 클래스명

<오버로딩 / 오버라이딩>

- 객체지향 프로그래밍에서 다형성을 이야기할 때 빼놓을 수 없는 개념
- 비슷한 기능을 하고 중복되는 구현이 필요하지만
오버로딩/오버라이딩을 적절히 사용할 수 있다면, 중복이 없는 최소한의 코드로
원하는 기능을 모두 구현할 수 있다.

<오버로딩>

- 자바는 매개변수의 자료형/개수/순서를 기반으로 메서드를 
구별하므로 하나의 클래스 안에서 같은 이름의 메서드를
여러 개 구현하고 필요에 따라 메서드를 선택해서 사용할 수 있다.

<오버라이딩>

- 부모 클래스에게 정의된 메서드를 재정의하여 자식 클래스에 상황에 맞게
구현하고 자식 객체를 통해 메서드를 호출하면 오버라이딩된 메서드를 호출하게 된다.

클래스 -> 객체에 대한 정보를 적는 설계도
	필드 person
	메서드 int age

<클래스 타입변환(기본자료형 형변환)>

-상속관계에서만 일어난다.

자동형변환
Parent p = new Child();
-자식객체가 부모타입으로 바뀔때
*자식 클래스에 따로 정의된 필드와 메서드는 사용못함
*부모의 필드나 메서드는 사용가능
*오버라이딩된 메서드는 사용가능

강제형변환
-부모타입이 자식객체로 바뀔때
-부모타입으로 변환된 자식 객체를 다시 자식타입으로 변경
Child c = (Child)p; (자식클래스에 있는 필드나 메서드를 사용할 수 있다.)


<추상화>
- 공통성과 본질을 모아 추출하는것
- 기존 클래스들의 공통적인 요소를 모아 상위클래스를
만들어내는 기술
- 공통적인 속성과 행위를 모아 정의하면, 반복적인 코드를
줄일 수 있고 보다 효과적인 클래스간의 관계를 설정하여 유지보수가 용이해진다.

<추상 메서드>
- 선언부만 작성하고 구현부는 작성하지 않고 남겨둔 미완성의 메서드
-다형성을 위해 메서드의 선언은 통일해야 하지만.
실제로 구현하는 내용은 자식클래스마다 달라야할때 사용한다. 
-부모클래스의 메서드는 비워두고 자식 클래스에서 오버라이딩하여 구현을 할 수 있다.
-추상 메서드를 선언할 때 abstract키워드를 함께 표기해야한다.

	(두가지 방법 가능)
	접근제한자 abstract 반환형(있으면하고 없으면 안함) 메서드명(매개변수);
	abstract 접근제한자 반환형(있으면하고 없으면 안함) 메서드명(매개변수);

<추상 클래스>
-추상 메서드가 한개이상 정의되어 있는 클래스를
추상 클래스라 한다.
-추상 메서드를 포함하고 있다는것을 제외하고 일반 클래스와 
다르지않다
-추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.
-추상 클래스 또한 abstract를 통해 자신이 추상 클래스임을 명시 해줘야한다.

public 'abstract' class 클래스명{
	필드
	생성자
	메서드(추상메서드)
}
<추상 클래스의 특징>
- 일반 클래스 처럼 독립적으로 생성자를 호출해 객체를 생성할 수 없다.
-자식 클래스의 생성자 super()를 통해 추상 클래스의 생성자를 
호출하여 부모 객체를 생성한 후 자식 객체를 생성한다.

<추상클래스는 언제 구현해야 할까?>
- 자식 클래스들이 반드시 구현해야하는 메서드가 있다면, 추상 메서드로 추상클래스에 만들어준다.
- 추상 클래스를 상속받은 모든 자식 클래스는 반드시 추상메서드를 
오버라이딩 및 재정의하여 구현해야한다. 


<추상 클래스와 추상 메서드의 용도>
- 자식 클래스 간의 공통적인 필드와 메서드 이름을 통일할 수 있다.
- 반드시 구현해야 하는 메서드를 선언함으로써 공통 규격을 제공한다.

<인터페이스 >
- 모든 메서드가 추상 메서드인 추상클래스를 '인터페이스'라고 부른다.
- 인터페이스는 추상 메서드와 상수로만 이루어져있으며, 추상클래스와
마찬가지로 스스로 객체를 생성할 수 없다.

<인터페이스의 선언>
- 인터페이스는 클래스가 아니다.
- 추상클래스는 자식 클래스의 생성자를 통해 객체를 생성해 낼 수 있었다.
- 하지만 인터페이스는 어떤 형태로도 객체를 만들 수 없기 때문에 클래스라고 부를 수 없다.

[접근제한자] interface 인터페이스명{
	상수
	추상메서드
}

<implements>
- 구현 클래스는 인터페이스를 사용해 구현하겠다는 선언을 해야 한다.
- 구현한다는 의미를 가지고 있는 implements키워드를 사용하여 명시할 수 있다.


인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 동일하며
class 키워드 대신 interface를 작성한다.
또한, 인터페이스의 추상 메서드는 다른 클래스들과의 매개체 역할을 하므로 누구나 접근할 수 있다.
따라서 항상 public으로 구현한다.
만약 접근자를 default로 구현했다면 자동으로 public으로 인식한다.

<인터페이스의 장점>
-정보은닉 : 실제 구현 클래스의 내용을 전혀 보지 않고도 개발 코드로 객체를 사용할 수 있다.
-모듈화 : 구현 클래스들이 독립적으로 구현되고 사용될 수 있다.
-개발코드에서 객체 변경이 필요할 때, 개발코드의 수정을 최소화 할 수 있다.

<추상클래스 와 인터페이스의 공통점>
-정보은닉,모듈화,추상화 등은 추상 클래스와 인터페이스가 공통적으로 가진 장점이다.
-추상 클래스와 인터페이스 모두 다형성을 구현할 수 있는 기반을 제공하며,
추상 메서드 구현에 대한 강제성을 반영하고 있다.





