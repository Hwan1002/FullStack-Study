8월6일자 복습

<생성자와 메서드 차이>

-생성자는 클래스명이 있고 메서드명은 마음대로 지정 가능하다.
-생성자 호출은 객체 생성시 new 를 통해 호출을 하고 메서드의 호출은 여러번이 가능하다
-생성자 반환값은 없으며 메서드는 있을수 있고 없을 수 있다.
생성자는 반환형 자체가 없으며 메서드의 반환값은 반환형 결정,void처리

<오버로딩>
같은 이름의 메서드(생성자)를 중복해서 정의하는것

1.메서드명(생성자명)이 같아야 한다.
2.매개변수의 개수가 달라야 한다.
3.매개변수의 개수가 같을 때 자료형이 달라야 한다. 

<오버라이딩>
-부모에 정의된 메서드를 자식의 상황에 맞게 재정의

1. 메서드명,반환형,매개변수 모두 같아야한다.
2. 내용만 달라야 한다.
3. 접근제한자는 부모의 메서드 보다 좁은 범위는 가능하다.

--------------------------------------------------------------------------------


<접근 제한자>

-제한자
클래스, 변수 또는 메서드의 선언부에 함께 사용해 부가적인 의미를 부여하는 키워드
경우에 따라 여러개를 조합하여 사용할 수 있지만, 접근 제한자의 경우 하나만 선택해서
사용해야한다.

-접근제한자
클래스,멤버(필드,메서드)에 접근 가능한 범위를 제한하는 키워드
객체지향 프로그래밍의 특징중 한 가지인 정보 은닉을 지키기 위한 중요한 부분이다.

-public :  제한없이 모든 패키지, 모든 클래스에서 접근이 가능하다.
-private : 같은 클래스 내에서만 접근이 가능하다.
-default : 같은 패키지 내에서만 접근이 가능하다.
-protected : 같은 패키지 안에서 접근 가능하며 다른 패키지라도 자식 클래스라면 접근이 가능하다

클래스의 접근제한자
-클래스는 접근제한자로 public과 default만 가질 수 있다.
-private과 protected의 경우, 클래스 멤버들을 위한 접근 제한자로 클래스 외부에서
접근을 막을지 말지에 대해 제한하는 용도로 사용되기 때문에 클래스의 접근제한자로
사용할 수 없다.


<객체지향의 특징>(면접질문)
-캡슐화
객체 내부의 멤버(필드,메서드 등)를 객체 외부에서 볼 수 없도록 캡슐화 한다.
접근이 필요한 경우 public 메서드를 활용해 접근하고, 이외의 값들은 모두 캡슐화를 통해
정보를 은닉한다.

-상속
미리 정의된 부모 클래스의 멤버를 자식 클래스가 물려받는다.

-다형성
하나의 방법으로 여러 객체를 호출하여 사용할 수 있다.

-추상화
공통된 기능과 정보를 추출해 객체화 한다.

<default>
-접근제한자를 따로 명시하지 않는다면 클래스와 멤버들은 자동으로 default를 가진다.
default로 선언된 클래스와 멤버들은 같은 패키지 안에서는 어디든지 접근 및 사용이 가능하나
다른 패키지에서는 접근이 불가능하다.


<protected>
- 클래스 멤버를 위한 제한자로, 상속과 관련이 있는 제한자이다.
default처럼 같은 패키지 안에서 접근과 사용을 허가 하지만, 
다른 패키지에서의 접근을완전히 제한하는것이 아닌
,"해당 클래스와 상속 관계에 있는 자식 클래스" 라면
 다른 패키지라도 접근 및 사용이 가능하다.

<private>
-가장 사용 범위가 좁은 클래스 멤버를 위한 제한자이다.
클래스가 public/default이더라도, private으로 선언된 멤버들은 클래스 외부에서 
접근이 불가능하다.
오직 선언된 클래스 내부에서만 접근하여 사용할 수 있다.

n차 상속
상속을 그 다음 세대에도 넘길 수 있다.
2차,3차....N차까지 원하는 만큼 상속을 이어받을 수 있다.

<final>
-final 키워드는 상수를 뜻하는 키워드로, 필드 앞에 선언하여 사용한다.
초기화후 값을 바꿀 수 없으며 시간이 지나도 처음 정의된 상태가 
변하지 않는다는 의미를 가지고있다.
이 키워드는 메서드와 클래스에도 사용할 수 있다.

<final 클래스>
클래스 앞에 final을 추가할 경우, 이 클래스는 상속의 마지막 클래스임을 뜻한다.

어떠한 클래스도 이 클래스 자식 클래스가 될 수  없고,
자연스럽게 이클래스는 어떠한 클래스의 부모 클래스도 될 수 없다.

<final 메서드>
-메서드 앞에 final을 추가하게 되면 상속은 받더라도,
오버라이딩 할 수 없는 메서드가 된다.
-즉, 자식 클래스더라도 부모클래스에 final로 선언된 메서드는
자식 클래스에서 오버라이딩 하지 못하고 있는 그대로 사용해야 한다.

생성자에는 final 을 붙힐 수 없다.
-생성자는 접근제한자만 추가할 수 있다.
-따라서 클래스를 final로 선언하더라도 생성자를 final 로 선언할 수 없다.

------------------------------------------------------------------------------------

<클래스에서의 타입변환>
-타입 변환은 타입을 다른 타입으로 변환하는것
-자바에서는 다음과 같이 두가지 타입 변환이 있다.
	- 자료형 변환
	- 클래스의 객체 타입 변환
-클래스의 타입변환도 마찬가지로 자동 타입변환과 강제 타입변환이 있다.
-단, 자료형에 비해 타입 변환이 가능한 범위가 상당히 좁다.
-클래스의 타입 변환은, 서로 상속 관계에 있는 클래스 사이에서만 변환할 수 있다.

<클래스의 자동 타입 변환>
-자료형에서의 자동 형 변환과 마찬가지로 개발자가 직접 명시하지 않아도
자동으로 타입 변환이 일어나는것을 '클래스 자동 타입 변환'이라고 한다.
-클래스 자동 타입 변환은 상속 관계에 있는 자식 클래스의 객체를
부모타입으로 변환하는것을 말한다.

부모타입 변수명 = new 자식클래스명();

이미 만들어진 자식 객체를 부모 타입으로 변환하려고 할 때는 다음과 같이 쓴다

부모타입 변수명 = 자식객체 변수명;







