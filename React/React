※ React Hook의 종류 ※

1. <useState>
ㄴ setState 기능에 prev를 넣어 전 state 값을 활용할 수 있다.

ex) setState(prev = prev +1) 
ㄴ setter함수 (setState)는 비동기로 진행하기 때문에
   여러번 호출할 경우 반영이 잘 안될 수 있다.
ex) setter(prev => 이전상태를 어떻게 바꿀것인지 정의)

<왜 State로 상태 관리를 해야할까?>

1. 불변성을 통한 상태관리
2. 참조비교를 이용한 변경감지
ㄴ 리액트는 얕은 비교를 사용해 이전 상태와 새로운 상태를 비교한다.
ㄴ 객체의 참조를 비교하는 방식으로 성능이 뛰어나고 불필요한 렌더링

2. <useEffect>
ㄴ 컴포넌트가 렌더링 될 때마다 원하는 작업이 실행되도록 설정가능.
ㄴ 렌더링이 될때 실행해야 하는 함수를 안에 정의 할 수 있다.
ㄴ 사용 방법 : 
   import {useEffect} from 'react'
   useEffect(()=>{
      렌더링시 실행되야 하는 함수
   },[])

ㄴ 첫번째 인자 : useEffect가 어떤 조건하에 하고자하는 명령
   두번째 인자 : useEffect가 언제 실행이 될건지 조건을 정하는 배열
   뒤에 []배열을 붙히면 최초 1회 렌더링시에만 실행 할 수 있고,
   다른 배열을 넣어서 조건을 붙힐 수 있다.
ex) useEffect(()=>{})         -> 매 렌더링마다 재실행
    useEffect(()=>{},[])      -> 컴포넌트가 마운트 될 때 실행
    useEffect(()=>{},[state]) -> 해당 state가 변경될 때마다 실행


3. <useRef>
ㄴ 리액트에서도 특정 컴포넌트를 선택 하거나 값을 보내는 경우
ㄴ 사용 방법 : 
   const refName = useRef(initialValue);
   current란 현재 initalValue

4. <useMemo>
ㄴ 


 
※ React 함수의 종류
<setInterval>
ㄴ 몇초마다 함수를 실행시킬 수 있다.
ex) setInterval(()=>{timer.current +=1;},1000)
1000 : 1초마다

주의할점
ㄴ 컴포넌트의 ref로 지정하면 생성된 변수의 값이 저장되는 것이 아니라
   변수의 .current 프로퍼티에 해당 값을 담는다.
ㄴ useState를 이용하여 생성된 상태와 달리 useRef의 내용이 변경돼도
   컴포넌트는 다시 렌더링 되지 않는다.













<비교연산자>-------------------------------------
React Native에서는 비교연산자가 다른 언어에 비해 다르게 작용한다.
ex) 
1. A && B -> A가 참이면 B를 실행하라
2. A || B -> A가 참이아니면 B를 실행하라



※React 문법 및 기능 정리※

1. 스프레드 연산자 (...)
-  객체 혹은 배열을 펼쳐 사용할 수 있다.
-  스프레드 연산자를 사용하면 객체를 새로 만들어 값을 넣어주는
   깊은 복사를 할 수 있다.
