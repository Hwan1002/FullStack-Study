※ React Hook의 종류 ※

   <useState>
   ㄴ setState 기능에 prev를 넣어 전 state 값을 활용할 수 있다.

ex) setState(prev = prev +1) 
ㄴ setter함수 (setState)는 비동기로 진행하기 때문에
   여러번 호출할 경우 반영이 잘 안될 수 있다.
ex) setter(prev => 이전상태를 어떻게 바꿀것인지 정의)

<왜 State로 상태 관리를 해야할까?>

1. 불변성을 통한 상태관리
2. 참조비교를 이용한 변경감지
ㄴ 리액트는 얕은 비교를 사용해 이전 상태와 새로운 상태를 비교한다.
ㄴ 객체의 참조를 비교하는 방식으로 성능이 뛰어나고 불필요한 렌더링


--------------------------------------------------------------------

   <useEffect>
   ㄴ 컴포넌트가 렌더링 될 때마다 원하는 작업이 실행되도록 설정가능.
   ㄴ 렌더링이 될때 실행해야 하는 함수를 안에 정의 할 수 있다.
   ㄴ 사용 방법 : 
      import {useEffect} from 'react'
      useEffect(()=>{
         렌더링시 실행되야 하는 함수
      },[])
   
   ㄴ 첫번째 인자 : useEffect가 어떤 조건하에 하고자하는 명령
      두번째 인자 : useEffect가 언제 실행이 될건지 조건을 정하는 배열
      뒤에 []배열을 붙히면 최초 1회 렌더링시에만 실행 할 수 있고,
      다른 배열을 넣어서 조건을 붙힐 수 있다.
   ex) useEffect(()=>{})         -> 매 렌더링마다 재실행
       useEffect(()=>{},[])      -> 컴포넌트가 마운트 될 때 실행
       useEffect(()=>{},[state]) -> 해당 state가 변경될 때마다 실행

   !!useEffect의 첫번째 요소인 함수에 비동기 (async) 함수가 오면 안되는 이유!!
   
   1. useEffect 자체가 비동기 (async) 동작을 직접적으로 지원을 안함
   2. useEffect의 첫번째 인자 반환값은 반드시 클린업 함수 또는 undefined여야 한다.
      비동기 (async) 함수를 사용하면 반환값이 promise가 된다.
   3. 비동기(async) 흐름으로 인한 예기치 않은 동작
   - useEffect 내부에서 비동기 처리를 직접적으로 작성하면, 이 비동기 (async) 함수가
     실행되는 동안 컴포넌트가 재렌더링 될 때, 상태가 변화해서 데이터가 꼬이거나,
     메모리 누수가 발생할 가능성이 높아진다.
   
   >>>> async란???
   ㄴ 함수 앞에 붙어서 해당 함수가 비동기 작업을 포함하고 있다는 걸 알려주는 키워드.
   ㄴ 비동기 작업을 포함하는 함수에 async를 붙히게 되면 그 함수는 promise라는 
      객체를 반환하게 된다.
   ㄴ promise는 자바스크립트가 이 작업이 완료되면 알려줄게 라고 일종의 약속같은 개념이다.
   ㄴ async 함수 안에서 await 키워드를 사용하여 특정 작업이 완료될 때 까지 기다려달라고 하는것.
      즉, Promise 가 완료될때 까지 기다렸다가 결과를 받아서 처리
      (await 덕분에 마치 동기 코드 처럼 차례대로 실행되는것 처럼 보이지만, 실제로는 비동기 작업)
-------------------------------------------------------------------------------------------
   
   <useLayoutEffect>
   ㄴ 화면에 그리기전에 실행된다.
   ㄴ 화면이 완전히 보이기 전에 UI를 수정할 수 있는 기회를 갖는다는 의미.
   ㄴ useEffect와 사용법 동일.
   ㄴ useEffect와 차이점은 컴포넌트가 업데이트된 직후, 화면이 렌더링 되기 전에 실행된다.

   <목적>
   - 컴포넌트의 레이아웃을 읽어오고 설정할때 사용
   - 화면 크기에 따라 UI 요소의 위치나 크기를 동적으로 조정해야 할 때 사용
   - 화면에 표시되는 요소를 바로잡고 레이아웃에 필요한 계산을 먼저 끝내는 용도.
   




-----------------------------------------------------------------------------------------
   <useRef>
   ㄴ 리액트에서도 특정 컴포넌트 및 엘리먼트를 선택 하거나 값을 보내는 경우
      (querySelector 처럼 태그를 선택할 수 있다.)
   
   ㄴ 리렌더링 없이 상태를 유지할 때 사용할 수 있다.
      useRef의 값이 바뀌어도 재렌더링이 되지 않기 때문에 값이 바뀌어도
      렌더링이 필요하지 않은 경우에 사용할 수 있다.
      사용처 : 타이머, 이전 값 추적, 스크롤 위치 추적
   
   ㄴ 사용 방법 : 
      const refName = useRef(initialValue); -> useRef 객체를 만든다.
      current란 현재 initialValue

--------------------------------------------------------------------------------------------
   <useMemo>
   ㄴ 메모이제이션을 활용해 특정 연산의 결과를 저장해두고,
      불필요한 반복 계산을 피하도록 도와준다.
      (＊메모이제이션 : 같은 계산을 반복해야 할 때 그 결과를 저장해주고,
       다시 필요할 때 저장된 값을 꺼내 사용하는 기법)
   
   ㄴ 이 Hook은 복잡한 계산이 매번 다시 이루어지지 않도록 최적화 하는 역할을 하고,
      의존성 배열에 따라 값이 바뀔 때만 연산이 다시 수행되도록 설정할 수 있다.
   
   ＊언제 사용하는 것이 좋을까?
   1. 비용이 큰 계산이나 반복 작업이 있을때 사용
   ㄴ 복잡한 배열 연산이나 필터링, 정렬등의 작업을 useMemo로 최적화 할수 있다.)
   
   2. 렌더링 성능이 중요한 경우
   ㄴ 불필요한 재계산이 자주 발생하는 경우, 이를 방지해 렌더링 성능을 높일 수 있다.
   ㄴ 사용 방법 :
      useMemo(()=>{},[])

---------------------------------------------------------------------------------------------

   <useReducer>
   ㄴ 현재 상태와, 상태를 어떻게 업데이트 할지를 정의한 함수를 통해
      새로운 상태를 반환
   
   ＊ 언제 사용하면 좋을까?
   
   1. 관리해야하는 상태가 여러개 일때
   useState를 사용해 각각의 상태를 관리하기보다는
   하나의 state 객체로 묶어서 관리하는것이 효율적이기 때문이다.
   
   2.복잡한 로직이 필요할때 : 상태 변경에 따라 다양한 조건을 검토하고,
   여러 단계를 거쳐서 상태를 변경해야 할때
   
   3. 상태 업데이트 로직을 컴포넌트 밖으로 분리하고 싶을 때
   reducer함수는 컴포넌트 외부에 둘 수도 있어서, 상태 관리 로직을
   명확히 분리할 수 있다.


   ＊주요개념
   state : 현재 컴포넌트의 상태값
   action : 상태를 어떻게 변경할지 나타내는 "명령"
   reducer : 현재 상태와 액션을 받아서 새로운 상태를 반환하는 함수
   
   ＊기본문법
   
   const [state, dispatch] = useReducer(reducer,initialState);
   ＊액션을 리듀서 함수로 보내는 역할 
   
   function reducer(state, action){
      switch(action.type){
         case 'INCREMENT' : 
            return {count: state.count + 1}
         case 'DECREMENT' : 
            return {count:state.count - 1}
      }
   }
   
   <Button onClick={() => dispatch({type:'INCREMENT'})}/>
   <Button onClick={() => dispatch({type:'DECREMENT'})}/>







==========================================================================================
※ React 함수의 종류
<setInterval>
ㄴ 몇초마다 함수를 실행시킬 수 있다.
ex) setInterval(()=>{timer.current +=1;},1000)
1000 : 1초마다

주의할점
ㄴ 컴포넌트의 ref로 지정하면 생성된 변수의 값이 저장되는 것이 아니라
   변수의 .current 프로퍼티에 해당 값을 담는다.
ㄴ useState를 이용하여 생성된 상태와 달리 useRef의 내용이 변경돼도
   컴포넌트는 다시 렌더링 되지 않는다.







<비교연산자>-------------------------------------
React Native에서는 비교연산자가 다른 언어에 비해 다르게 작용한다.
ex) 
1. A && B -> A가 참이면 B를 실행하라
2. A || B -> A가 참이아니면 B를 실행하라



※React 문법 및 기능 정리※

1. 스프레드 연산자 (...)
-  객체 혹은 배열을 펼쳐 사용할 수 있다.
-  스프레드 연산자를 사용하면 객체를 새로 만들어 값을 넣어주는
   깊은 복사를 할 수 있다.
